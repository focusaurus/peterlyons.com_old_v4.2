<p>
Reading <a href="http://factor-language.blogspot.com/2010/09/two-things-every-unix-developer-should.html">this blog post</a> just makes me cringe.  This is why I  am so persistently hesitant to bother with C and low level systems programming.  They are broken. They are impossible to get right.  If even after numerous decades, the <em>cat</em> program still has bugs in basic system interaction, it's not the programmers, it's the system. Thanks, but no. I'll code in a high level language that lets me focus on delivering functionality to my users, not performing sacrificial rituals to the Gods of K&R, signal processing, and bitmasks.
</p>
<p>
At work we have certain code bases that no matter how long we tweak them and how many dozens of bugs we fix, they just never reach a point of stability and reliability.  You need to just abandon them and rethink the problem from scratch.  Come at it with a different approach and a brand new code base and some analysis that actually addresses all of the edge cases.
</p>
<p>
Interestingly, I think the mobile space (iOS, Android) have potential to finally provide a next generation operating system where applications written by average, normal programmers usually function perfectly.  Contrast this to most existing operating systems where most programs can be easily made to crash or misbehave in the course of normal use. We've got to get beyond this notion that in order to make a well-behaved application, the developer needs encyclopedic knowledge of bizzarre archaic minutia of the underlying OS.
</p>
<p>
Incidentally, that post is written by <a href="http://factorcode.org/slava/">Slava Pestov</a>, the creator of the jEdit text editor that has been my primary editor for many years.  This guy is good.
</p>